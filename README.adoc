// Copyright (c) 2018 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-layout: guide
:projectid: jpa-intro
:page-duration: 20 minutes
:page-releasedate: 2018-07-18
:page-description: Learn how to use Java Persistence API to access and persist data to a database for your microservices.
:page-tags: ['JPA']
:page-related-guides: ['cdi-intro']
:page-permalink: /guides/{projectid}
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
= Accessing and persisting data in microservices

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, 
view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to use Java Persistence API to access and persist data to a database for your microservices.

:eventapp-url: http://localhost:9080/eventmanager.jsf
:get-events-url: http://localhost:9080/events

== What you'll learn

You will learn how to use the Java Persistence API (JPA) to map Java objects to relational database 
tables and perform create, read, update and delete (CRUD) operations on the data in your microservices. 

JPA is a Java specification for representing relational database table data as Plain Old Java Objects (POJO).
JPA simplifies object-relational mapping (ORM) by using annotations to map Java objects 
to tables in a relational database. In addition to providing an efficient API for performing
CRUD operations, JPA also reduces the burden of having to write JDBC and SQL code when performing
database operations and takes care of database vendor-specific differences. This capability allows you to 
focus on the business logic of your application instead of wasting time implementing repetitive CRUD logic.

The application that you will be working with is an event manager, which is composed of a UI and 
an event microservice for creating, retrieving, updating, and deleting events. The application uses an 
Embedded Derby database as a data store for all the events.

You will use JPA annotations to define an entity class whose fields are persisted to the 
database. The interaction between your application and the database is mediated by the persistence 
context that is managed by an entity manager. The entity manager can be application-managed or
container-managed. In this guide you will use a container-managed entity manager, placing the
burden of managing the lifecycle of an EntityManager instance on the application server. The lifecycle of the
persistence context can either be transaction-scoped or extended when you use a container-managed 
entity manager. You will be focused on using a container-managed entity manager with a 
transaction-scoped persistence context to take advantage of the application server's services.


// =================================================================================================
// Getting Started
// =================================================================================================

include::{common-includes}/gitclone.adoc[]

// =================================================================================================
// Try what you'll build
// =================================================================================================

include::{common-includes}/trywhatyoubuild-intro.adoc[]

Point your browser to the {eventapp-url} URL. The event application does not display any events
because no events are stored in the database. Go ahead and click `Create Event`, located in the 
left navigation bar. After entering an event name, location and time, click `Submit` to persist your 
event entity to the database. The event is now stored in the database and is visible in the list of 
current events.

Notice that if you stop the Open Liberty server and then restart it, the events created
are still displayed in the list of current events. Run the following Maven goals to stop
and then restart the server:
```
mvn liberty:stop-server
mvn liberty:start-server
```

The events created are still displayed in the list of current events. The `Update` button located 
beside each event allows you to make modifications to the persisted entity and the `Delete` button 
allows you to remove entities from the database.

include::{common-includes}/trywhatyoubuild-end.adoc[]

// =================================================================================================
// Defining a JPA entity class
// =================================================================================================

== Defining a JPA entity class

Navigate to the `start` directory to begin.

To store Java objects in a database, you must define a JPA entity class. A JPA entity is a Java 
object whose non-transient and non-static fields will be persisted to the database. Any Plain Old 
Java Object (POJO) class can be designated as a JPA entity. However, the class must be annotated
with the `@Entity` annotation, must not be declared final and must have a public or protected non-argument
constructor. JPA maps an entity type to a database table and persisted instances will be represented 
as rows in the table.

The `Event` class is a model that represents events in the application and is annotated with JPA
annotations. Create the `Event` class in the `src/main/java/io/openliberty/guides/models/Event.java` file:
[source, Java]
----
include::finish/src/main/java/io/openliberty/guides/models/Event.java[tags=!copyright;]
----

The following table breaks down the new annotations:

[cols="35, 200", options="header"]
|===
| *Annotation*    | *Description*
| `@Entity` | Declares the class as an entity
| `@Table`  | Specifies details of the table such as name 
| `@NamedQuery` | Specifies a predefined database query that is run by an EntityManager instance.
| `@Id`       |  Declares the pimary key of the entity
| `@GeneratedValue`    | Specifies the generation strategy for the value of the primary key. 
                        The `strategy = GenerationType.AUTO` code indicates that a generation strategy 
                        is chosen based on the database that is used
| `@Column`    | Specifies that the field is mapped to a column in the database table. The `name`
                 attribute is optional and indicates the name of the column in the table
|===

// =================================================================================================
// Creating the persistence.xml
// =================================================================================================

== Creating the persistence.xml file

The `persistence.xml` file is a configuration file that defines a persistence unit. The 
persistence unit contains configuration information for the entity manager, the transaction
type, and the data source that the application uses. 

Create the `src/main/resources/META-INF/persistence.xml` file:

[source, Xml]
----
include::finish/src/main/resources/META-INF/persistence.xml[tags=**;]
----

The persistence unit is defined by the `<persistence-unit>` XML element. The `name` attribute is 
required and is used to identify the persistent unit when using the `@PersistenceContext`
annotation later in this guide. The `transaction-type=”JTA”` element specifies 
that the persistence context enlists in Java Transaction API (JTA) global transactions. Since 
we are using a container-managed entity manager, JTA transactions must be used. 

A JTA transaction type requires a JTA data source to be provided. The data source is defined through the 
`eventjpadatasource` element that specifies the Java Naming and Directory Interface (JNDI) name of 
the data source that is used. The data source has already been configured for you
in the `src/main/liberty/config/server.xml` file. This data source configuration is where 
the Java Database Connectivity (JDBC) connection is defined along with some database
vendor-specific properties.

The `eclipselink.ddl-generation` properties are used here so that you aren't required to 
manually create a database table to run this sample application. To learn more about the 
`ddl-generation` properties, see the 
http://www.eclipse.org/eclipselink/documentation/2.5/jpa/extensions/p_ddl_generation.htm[JPA Extensions Reference for EclipseLink.]

// =================================================================================================
// Performing CRUD operations using JPA
// =================================================================================================

== Performing CRUD operations using JPA

To perform CRUD operations by using JPA, create the `src/main/java/io/openliberty/guides/dao/EventDao.java` 
file:

[source, Java]
----
include::finish/src/main/java/io/openliberty/guides/dao/EventDao.java[tags=!copyright;]
----

To use the entity manager at runtime, inject it into our CDI bean through the
`@PersistenceContext` annotation. The entity manager interacts with the persistence context. 
Every EntityManager instance is associated with a persistence context. The persistence context 
manages a set of entities and is aware of the different states that an entity can have.
The persistence context then synchronizes with the database when a transaction commits.

 The `@Transactional` annotation allows the application to manage
transaction boundaries on CDI-managed beans. This transaction management ensures that 
the required methods run within the boundaries of an active global transaction,
which is why it is not necessary to explicitly begin, commit or rollback transactions.

Since we are using a transaction-scoped persistence context, a new persistence context begins when
an EntityManager instance is invoked within an active transaction and ends when the transaction commits or 
rolls back.  At the end of the transactional method invocation, the persistence context 
is notified that the transaction is committing, and flushes any changes made to entity instances 
it is managing to the database. The managed entities then become detached. 

The `EventDao.java` class has a method for each CRUD operation, so let's break them down:

* The `createEvent()` method persists an instance of the `Event` entity class to the data store by
calling the `persist()` method on an EntityManager instance. The event objects state 
changes from new to managed and changes to it are now tracked by the entity manager. 

* The `readEvent()` method returns an instance of the `Event` entity class with the specified primary 
key by calling the `find()` method on an `EntityManager` instance. If the event instance is found, it
is returned in a managed state, but, if the event instance is not found, `Null` is returned.

* The `readAllEvents()` method demonstrates an alternate way to retrieve event objects from the database.
This method returns a list of instances of the `Event` entity class by using a query specified in the `@NamedQuery` 
annotation on the `Event` class. 

* The `updateEvent()` method creates a managed instance of a detached entity object. The entity manager 
automatically tracks all managed entity objects in its persistence context for changes and
synchronizes them with the database. However, if an entity becomes detached, you must merge that entity
into the persistence context by calling the `merge()` method so that changes to loaded 
fields of the detached entity are tracked.

* The `deleteEvent()` method removes an instance of the `Event` entity class from the database by 
calling the `remove()` method on an `EntityManager` instance. The state of the entity is
changed to removed and is removed from the database upon transaction commit. 

You can then inject the `EventDao` class into other components of your application. Notice how
it is injected into the `src/main/java/io/openliberty/resources/EventService.java` file to provide
the `EventService` class with a way to persist and access data.

// =================================================================================================
// Building and running the application
// =================================================================================================

include::{common-includes}/mvnbuild.adoc[]

When the server is running, go to the {eventapp-url} URL to view the Event Manager application. 

Click `Create event` in the left navigation bar to create events that are persisted to 
the database. After you create an event, it is available to view, update, and delete in
the `Event list` section.

// Use the following include to pull in the Liberty start/stop server instructions from the
// guides-common repo.
include::{common-includes}/mvncompile.adoc[]

// Instructions to rebuild the application

// =================================================================================================
// Testing the application
// =================================================================================================

== Testing the application

Create the `EventEntityTest` test class in the `src/test/java/it/io/openliberty/guides/event/EventEntityTest.java` 
file:

[source, Java]
----
include::finish/src/test/java/it/io/openliberty/guides/event/EventEntityTest.java[tags=!copyright;]
----

The `testCRUD()` method creates a test event and persists it to the database. The event object is then 
retrieved from the database to verify that the test event was actually persisted. Next, the  
name, location, and time of the test event are updated. The event object is retrieved 
from the database to verify that the updated event is stored. Finally, the updated test 
event is deleted and one final check is done to ensure that the updated test event is no longer 
stored in the database.

// Include this for info on how to run the tests
include::{common-includes}/mvnverify.adoc[]

[source, role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.jpaguide.tests.EventEntityTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.9 sec - in it.io.openliberty.guides.jpaguide.tests.EventEntityTest

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
----

// =================================================================================================
// Great work! You're done!
// =================================================================================================

== Great work! You're done!

You learned how to map Java objects to database tables by defining a JPA entity class whose 
instances are represented as rows in the table.

You have learned how to configure an entity manager and use container-managed transactions
to perform basic CRUD operations on a database by using JPA. 

include::{common-includes}/finish.adoc[]
